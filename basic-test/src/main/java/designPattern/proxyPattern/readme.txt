Proxy代理模式(委托模式)是一种结构型设计模式
适用场景：
1、当不想访问某个对象或者访问某个对象存在困难时
2、原始对象存在不同的访问权限
3、在原始对象访问时需要补充一些附加操作

本案例以生活中租房为模板，设定场景如下：
小明需要租房，但是自己没时间，所以找了租房中介帮忙租房
在上述的场景中，会出现如下几个类和接口
1、IRoom 公共接口，用于定义租房流程需要的基本操作
2、XiaoMing implements IRoom , 小明类，实现IRoom接口，定义自己的租房流程
3、RoomAgency implements IRoom , 房屋中介，同样实现了IRoom接口，但是会注入XiaoMing对象，通过XiaoMing实例来调用具体的看房流程方法
4、Client  客户端

观察上面的角色会发现，实际上房屋中介和小明都是实现了IRoom接口，保证了小明对象的业务能够被实现，其次房屋中介可以在自己的实现方法中添加额外的操作

缺点：上述的例子中属于静态代理模式，代理对象和被代理对象必须实现相同的接口或者抽象类，存在很强的冗余性
例如：当小明需要买房时，就需要再实现买房接口，并且再创建一个代理对象，当复杂度越来越高时，系统就会充满代理类和被代理类。


和动态代理的区别：
静态代理在代码运行之前，代理类的.class文件已经生成
动态代理的.class文件则是在运行时才生成，实现方式有两种，JDK动态代理和Cglib动态代理
