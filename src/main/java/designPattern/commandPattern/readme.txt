命令模式：
将一个请求封装为一个对象，从而使用户可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
应用场景：
①程序需要在不同的时刻指定、排列和执行请求
②程序需要提供撤销操作
③程序需要支持宏操作
优点：
①在命令模式中，请求者（Invoker）不直接与接受者（Receiver）交互，即请求者（Invoker）不包含接受者（Receiver）的引用，因此彻底消除了彼此间的耦合
②命令模式满足“开-闭原则”。如果增加新的具体命令和该命令的接受者，不必修改调用者的代码，调用者就可以使用新的命令对象；反之，如果增加新的调用者，
不必修改现有具体命令和接收者，新增加的调用者就可以使用已有的具体命令。
③由于请求者的请求被封装到具体的命令中，那么就可以将具体命令保存到持久化的媒介中，在需要的时候，重新执行这个具体命令。因此，使用命令模式可以记录日志。
④使用命令模式可以对请求者的“请求”进行排队。每个请求都各自对应一个具体命令，因此可以按一定顺序执行这些具体命令

在本案例中，使用AudioPlayer案例来模拟命令模式中的主题程序+宏指令案例
成员角色：
请求者，接收者，客户端，抽象命令，实际命令，宏命令接口
成员关系：
接收者提供底层操作：play(),rewind(),stop()
抽象命令提供一个execute方法
实际命令implements抽象命令，在execute中执行对应的play/rewind/stop
请求者包含实际命令的全局变量，提供对外访问用于执行具体命令
客户端(模拟人为动作),创建接收者对象，作为Command的构造器入参，创建请求者对象，将command作为请求者方法执行的参数
宏命令接口extends 抽象命令，新增了add和remove接口，可以在宏命令的实际实现中将全局变量的List<Command>进行增删，最后在客户端中就可以不用请求者对象，使用宏对象来进行批量动作的完成

业务场景如下：
模拟用户输入的指令到CommandClient, 在main函数中进行将执行的接收者初始化给command的实际对象
最后使用请求者提供的方法来执行对应的命令



